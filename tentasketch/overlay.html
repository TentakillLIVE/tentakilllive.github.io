<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Stream Overlay</title>
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }
    html, body {
      width: 100vw;
      height: 100vh;
      overflow: hidden;
      background: transparent !important;
    }
    #overlay-canvas-container {
      width: 100vw;
      height: 100vh;
      position: fixed;
      top: 0;
      left: 0;
    }
    /* Fabric creates two canvas elements — scale both via CSS to fill the viewport */
    #overlay-canvas-container canvas {
      display: block;
      position: absolute;
      top: 0;
      left: 0;
      width: 100vw !important;
      height: 100vh !important;
    }

    /* Connection status indicator */
    #status {
      position: fixed;
      top: 8px;
      right: 8px;
      padding: 4px 10px;
      border-radius: 20px;
      font-family: monospace;
      font-size: 11px;
      color: #fff;
      z-index: 9999;
      opacity: 0;
      transition: opacity 0.3s;
      pointer-events: none;
    }
    #status.connecting { background: #f59e0b; opacity: 1; }
    #status.error { background: #ef4444; opacity: 1; }
    #status.connected {
      background: #22c55e;
      opacity: 1;
      animation: fadeOut 0.5s 2s forwards;
    }
    @keyframes fadeOut { to { opacity: 0; } }

    /* Setup prompt */
    #setup-prompt {
      position: fixed;
      inset: 0;
      display: flex;
      align-items: center;
      justify-content: center;
      background: rgba(0,0,0,0.85);
      color: #e2e8f0;
      font-family: 'Courier New', monospace;
      z-index: 10000;
    }
    #setup-prompt .box {
      max-width: 520px;
      padding: 32px;
      border: 1px solid #334155;
      border-radius: 12px;
      background: #0f172a;
    }
    #setup-prompt h2 { color: #38bdf8; margin-bottom: 12px; font-size: 18px; }
    #setup-prompt p { font-size: 13px; line-height: 1.6; color: #94a3b8; margin-bottom: 8px; }
    #setup-prompt code { color: #f472b6; background: #1e293b; padding: 1px 5px; border-radius: 3px; font-size: 12px; }
  </style>
</head>
<body>
  <div id="status">Connecting...</div>
  <div id="overlay-canvas-container">
    <canvas id="overlay-canvas"></canvas>
  </div>

  <div id="setup-prompt" style="display:none;">
    <div class="box">
      <h2>⚙️ Firebase Not Configured</h2>
      <p>Open <code>firebase-config.js</code> and add your Firebase project credentials.</p>
      <p>See the <code>README.md</code> for step-by-step setup instructions.</p>
    </div>
  </div>

  <!-- Firebase SDK -->
  <script src="https://www.gstatic.com/firebasejs/10.12.2/firebase-app-compat.js"></script>
  <script src="https://www.gstatic.com/firebasejs/10.12.2/firebase-database-compat.js"></script>

  <!-- Shared Firebase config -->
  <script src="firebase-config.js"></script>

  <!-- Fabric.js -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/fabric.js/5.3.1/fabric.min.js"></script>

  <script>
    const statusEl = document.getElementById('status');
    const setupPrompt = document.getElementById('setup-prompt');

    // ─── Check config ───
    if (!window.FIREBASE_CONFIG || !window.FIREBASE_CONFIG.apiKey || window.FIREBASE_CONFIG.apiKey === 'YOUR_API_KEY_HERE') {
      setupPrompt.style.display = 'flex';
      throw new Error('Firebase not configured. Edit firebase-config.js');
    }

    // ─── Init Firebase ───
    firebase.initializeApp(window.FIREBASE_CONFIG);
    const db = firebase.database();

    // ─── Get room from URL params ───
    const params = new URLSearchParams(window.location.search);
    const roomId = params.get('room') || 'default';

    // ─── Canvas resolution — defaults, updated from Firebase ───
    let canvasWidth = 1920;
    let canvasHeight = 1080;

    // ─── Init Fabric canvas (non-interactive) ───
    const canvas = new fabric.Canvas('overlay-canvas', {
      selection: false,
      interactive: false,
      renderOnAddRemove: false,
      backgroundColor: 'transparent',
      width: canvasWidth,
      height: canvasHeight,
    });

    // CSS handles stretching to fill the viewport.
    // Fabric's internal coordinate system stays at the logical resolution.

    // ─── Listen for canvas size from editor ───
    db.ref(`rooms/${roomId}/canvasSize`).on('value', (snapshot) => {
      const size = snapshot.val();
      if (size && size.width && size.height) {
        canvasWidth = size.width;
        canvasHeight = size.height;
        canvas.setWidth(canvasWidth);
        canvas.setHeight(canvasHeight);
        // Re-render with new dimensions
        if (Object.keys(objectCache).length > 0) {
          renderObjects(objectCache);
        }
      }
    });

    // ─── Listen for real-time object changes ───
    const roomRef = db.ref(`rooms/${roomId}/objects`);

    statusEl.className = 'connecting';
    statusEl.textContent = 'Connecting...';

    let objectCache = {};

    roomRef.on('value', (snapshot) => {
      statusEl.className = 'connected';
      statusEl.textContent = 'Connected';

      const data = snapshot.val() || {};
      objectCache = data;
      renderObjects(data);
    }, (error) => {
      statusEl.className = 'error';
      statusEl.textContent = 'Connection error';
      console.error('Firebase error:', error);
    });

    function renderObjects(objectsMap) {
      canvas.clear();
      canvas.backgroundColor = 'transparent';

      // Filter to only objects visible to all (not editor-only or hidden)
      const visibleKeys = Object.keys(objectsMap).filter(key => {
        const objData = objectsMap[key];
        return objData && objData.fabricData && (objData.visibility === 'all');
      });

      const sortedKeys = visibleKeys.sort((a, b) => {
        const orderA = objectsMap[a]?.zIndex || 0;
        const orderB = objectsMap[b]?.zIndex || 0;
        return orderA - orderB;
      });

      let loaded = 0;
      const total = sortedKeys.length;

      if (total === 0) {
        canvas.renderAll();
        return;
      }

      sortedKeys.forEach((key) => {
        const objData = objectsMap[key];

        fabric.util.enlivenObjects([objData.fabricData], (objects) => {
          objects.forEach((obj) => {
            obj.selectable = false;
            obj.evented = false;
            obj.hasControls = false;
            obj.hasBorders = false;
            // Freehand paths default to black fill — force transparent
            if (obj.type === 'path') {
              const f = obj.fill;
              if (!f || f === '#000000' || f === 'black' || f === 'rgb(0,0,0)' || f === '') {
                obj.set('fill', 'rgba(0,0,0,0)');
              }
            }
            canvas.add(obj);
          });
          loaded++;
          if (loaded >= total) {
            canvas.renderAll();
          }
        });
      });
    }
  </script>
</body>
</html>